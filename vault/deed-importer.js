// ============================================================
// 0nMCP — Vault: Deed Importer
// ============================================================
// Writes decrypted deed contents back to live system config.
// Generates .0n connection files, .env files, MCP platform
// configs, and restores workflows and AI brain data.
//
// Patent Pending: US Provisional Patent Application #63/990,046
// ============================================================

import { existsSync, mkdirSync, writeFileSync, readdirSync } from "fs";
import { join } from "path";
import { homedir } from "os";

const DOT_ON = join(homedir(), ".0n");
const CONNECTIONS_DIR = join(DOT_ON, "connections");
const WORKFLOWS_DIR = join(DOT_ON, "workflows");
const BRAIN_DIR = join(DOT_ON, "brain");

function ensureDir(dir) {
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
}

// ── Write .0n Connection Files ──────────────────────────────

/**
 * Write service credentials as .0n connection files.
 *
 * @param {Object} credentials - { service: { field: value } }
 * @param {string} dir - Target connections directory
 * @returns {{ written: string[], skipped: string[] }}
 */
function writeConnectionFiles(credentials, dir) {
  ensureDir(dir);
  const written = [];
  const skipped = [];

  for (const [service, creds] of Object.entries(credentials)) {
    try {
      const connection = {
        $0n: {
          type: "connection",
          version: "1.0.0",
          service,
          created: new Date().toISOString(),
          source: "business_deed_import",
        },
        credentials: creds,
      };

      const filePath = join(dir, `${service}.0n`);
      writeFileSync(filePath, JSON.stringify(connection, null, 2));
      written.push(service);
    } catch (err) {
      skipped.push(`${service}: ${err.message}`);
    }
  }

  return { written, skipped };
}

// ── Generate .env File ──────────────────────────────────────

/**
 * Write environment variables to a .env file.
 *
 * @param {Object} envVars - { KEY: value }
 * @param {string} filePath - Output .env path
 * @returns {{ written: number, file: string }}
 */
function writeEnvFile(envVars, filePath) {
  const lines = [
    `# Generated by 0nMCP Business Deed Import`,
    `# ${new Date().toISOString()}`,
    "",
  ];

  for (const [key, value] of Object.entries(envVars)) {
    // Quote values that contain spaces or special chars
    const needsQuotes = /[\s#"'\\]/.test(value);
    lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
  }

  writeFileSync(filePath, lines.join("\n") + "\n");
  return { written: Object.keys(envVars).length, file: filePath };
}

// ── Write Workflow Files ────────────────────────────────────

/**
 * Write workflow definitions to ~/.0n/workflows/.
 *
 * @param {Array|Object} workflows - Workflow definitions
 * @param {string} dir - Target workflows directory
 * @returns {{ written: string[], count: number }}
 */
function writeWorkflowFiles(workflows, dir) {
  ensureDir(dir);
  const written = [];

  const items = Array.isArray(workflows) ? workflows : [workflows];

  for (const workflow of items) {
    try {
      const name = workflow?.$0n?.name || workflow?.name || `workflow-${Date.now()}`;
      const safeName = name.replace(/[^a-zA-Z0-9_-]/g, "_");
      const filePath = join(dir, `${safeName}.0n`);
      writeFileSync(filePath, JSON.stringify(workflow, null, 2));
      written.push(safeName);
    } catch {
      // Skip invalid workflows
    }
  }

  return { written, count: written.length };
}

// ── Write MCP Configs ───────────────────────────────────────

/**
 * Write MCP platform configurations.
 *
 * @param {Object} mcpConfigs - MCP configuration data
 * @param {string} targetDir - Target directory
 * @returns {{ written: string[] }}
 */
function writeMcpConfigs(mcpConfigs, targetDir) {
  const written = [];

  if (mcpConfigs.platforms && typeof mcpConfigs.platforms === "object") {
    for (const [platform, config] of Object.entries(mcpConfigs.platforms)) {
      try {
        const filePath = join(targetDir, `mcp-${platform}.json`);
        writeFileSync(filePath, JSON.stringify(config, null, 2));
        written.push(platform);
      } catch {
        // Skip
      }
    }
  }

  // Write raw config if present
  if (mcpConfigs.servers) {
    try {
      const filePath = join(targetDir, "mcp-config.json");
      writeFileSync(filePath, JSON.stringify(mcpConfigs, null, 2));
      written.push("mcp-config");
    } catch {
      // Skip
    }
  }

  return { written };
}

// ── Write AI Brain Data ─────────────────────────────────────

/**
 * Write AI brain data to ~/.0n/brain/.
 *
 * @param {Object} aiBrain - AI brain data
 * @param {string} dir - Target brain directory
 * @returns {{ written: string[] }}
 */
function writeBrainData(aiBrain, dir) {
  ensureDir(dir);
  const written = [];

  // Write each brain section as a separate file
  for (const [section, data] of Object.entries(aiBrain)) {
    try {
      const filePath = join(dir, `${section}.json`);
      writeFileSync(filePath, JSON.stringify(data, null, 2));
      written.push(section);
    } catch {
      // Skip
    }
  }

  return { written };
}

// ── Master Import Function ──────────────────────────────────

/**
 * Import all deed layers into the live system.
 *
 * @param {Object} layers - Decrypted layer data
 * @param {string} [targetDir] - Base target directory (default: ~/.0n/)
 * @returns {Object} Import report
 */
export function importDeedToSystem(layers, targetDir = null) {
  const baseDir = targetDir || DOT_ON;
  const connectionsDir = join(baseDir, "connections");
  const workflowsDir = join(baseDir, "workflows");
  const brainDir = join(baseDir, "brain");

  ensureDir(baseDir);

  const report = {
    success: true,
    timestamp: new Date().toISOString(),
    connections: { written: [], skipped: [] },
    envFile: null,
    workflows: { written: [], count: 0 },
    mcpConfigs: { written: [] },
    brain: { written: [] },
    siteProfiles: null,
    deed: null,
    errors: [],
  };

  // 1. Import credentials as .0n connection files
  if (layers.credentials && typeof layers.credentials === "object" && !layers.credentials.error) {
    try {
      report.connections = writeConnectionFiles(layers.credentials, connectionsDir);
    } catch (err) {
      report.errors.push(`credentials: ${err.message}`);
    }
  }

  // 2. Generate .env file from env_vars
  if (layers.env_vars && typeof layers.env_vars === "object" && !layers.env_vars.error) {
    try {
      const envPath = join(baseDir, ".env.deed");
      report.envFile = writeEnvFile(layers.env_vars, envPath);
    } catch (err) {
      report.errors.push(`env_vars: ${err.message}`);
    }
  }

  // 3. Write workflows
  if (layers.workflows && !layers.workflows.error) {
    try {
      report.workflows = writeWorkflowFiles(layers.workflows, workflowsDir);
    } catch (err) {
      report.errors.push(`workflows: ${err.message}`);
    }
  }

  // 4. Write MCP configs
  if (layers.mcp_configs && typeof layers.mcp_configs === "object" && !layers.mcp_configs.error) {
    try {
      report.mcpConfigs = writeMcpConfigs(layers.mcp_configs, baseDir);
    } catch (err) {
      report.errors.push(`mcp_configs: ${err.message}`);
    }
  }

  // 5. Write site profiles
  if (layers.site_profiles && typeof layers.site_profiles === "object" && !layers.site_profiles.error) {
    try {
      const profilePath = join(baseDir, "site-profiles.json");
      writeFileSync(profilePath, JSON.stringify(layers.site_profiles, null, 2));
      report.siteProfiles = { file: profilePath };
    } catch (err) {
      report.errors.push(`site_profiles: ${err.message}`);
    }
  }

  // 6. Write AI brain data
  if (layers.ai_brain && typeof layers.ai_brain === "object" && !layers.ai_brain.error) {
    try {
      report.brain = writeBrainData(layers.ai_brain, brainDir);
    } catch (err) {
      report.errors.push(`ai_brain: ${err.message}`);
    }
  }

  // 7. Extract deed metadata from audit_trail
  if (layers.audit_trail?.deed) {
    report.deed = layers.audit_trail.deed;
  }

  report.success = report.errors.length === 0;
  return report;
}
